# -*- coding: utf-8 -*-
"""ML3_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15Rje8J4YujDUdcrjvz4xYXBE84pXjAIa

##Методические указания
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

data = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/gen_regression.csv")

data.head()

X = data.x
y = data.y

plt.scatter(X, y)

X = pd.DataFrame(X)

from sklearn.linear_model import LinearRegression
linear = LinearRegression().fit(X, y)

X = pd.DataFrame(X)

xx = np.arange(X.x.min(axis=0), X.x.max(axis=0))
yy = linear.predict(pd.DataFrame(xx))

plt.scatter(X.x, y)
plt.plot(xx, yy, c='r')

linear.score(X, y)

from sklearn.preprocessing import PolynomialFeatures

transformation = PolynomialFeatures(degree=2)

transformation.fit(X)

X_2 = transformation.transform(X)

X_2.shape
X_2[:5]

poly_2d = LinearRegression().fit(X_2, y)

xx_2d = transformation.transform(pd.DataFrame(xx))

yy_2d = poly_2d.predict(xx_2d)
plt.scatter(X.x, y)
plt.plot(xx, yy_2d, c='r')

poly_2d.score(X_2, y)

data = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/gen_classification.csv",
                   index_col=0)

y = data.y
X = data.drop(["y"], axis=1)

plt.scatter(X.iloc[:, 0][y==0], X.iloc[:, 1][y==0], marker="o", c='r', s=100)
plt.scatter(X.iloc[:, 0][y==1], X.iloc[:, 1][y==1], marker="x", c='b', s=100)

from sklearn.linear_model import LogisticRegression

logistic = LogisticRegression().fit(X, y)

xx, yy = np.meshgrid(
    np.arange(X.min()[0], X.max()[0]+0.1, 0.01),
    np.arange(X.min()[1], X.max()[1]+0.1, 0.01))
XX = np.array(list(zip(xx.ravel(), yy.ravel()))).reshape((-1, 2))

Z = logistic.predict(XX).reshape(xx.shape)

plt.contourf(xx, yy, Z, alpha=0.4)
plt.scatter(X.iloc[:, 0][y==0], X.iloc[:, 1][y==0], marker="o", c='r', s=100)
plt.scatter(X.iloc[:, 0][y==1], X.iloc[:, 1][y==1], marker="x", c='b', s=100)

logistic.score(X, y)

class_transform = PolynomialFeatures(degree=3, include_bias=False)
X_3 = class_transform.fit_transform(X)

X_3.shape

class_3 = LogisticRegression().fit(X_3, y)

Z = class_3.predict(class_transform.transform(XX)).reshape(xx.shape)

plt.contourf(xx, yy, Z, alpha=0.4)
plt.scatter(X.iloc[:, 0][y==0], X.iloc[:, 1][y==0], marker="o", c='r', s=100)
plt.scatter(X.iloc[:, 0][y==1], X.iloc[:, 1][y==1], marker="x", c='b', s=100)

class_3.score(X_3, y)

data_kc_prices = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/kc_house_data.csv")
data_kc_prices.shape

data_kc_prices.head()

y_kc_prices = data_kc_prices.price
X_kc_prices = data_kc_prices.drop(["id", "date", "price"], axis=1)

X_kc_prices.shape, y_kc_prices.shape

reg_kc_multiple = LinearRegression().fit(X_kc_prices, y_kc_prices)
reg_kc_multiple.score(X_kc_prices, y_kc_prices)

y_pred_kc_prices = reg_kc_multiple.predict(X_kc_prices)
plt.scatter(y_pred_kc_prices, y_kc_prices)
plt.plot(y_pred_kc_prices, y_pred_kc_prices, c='r')

X_3_kc_prices = (poly_features_kc_prices := PolynomialFeatures(degree=3)).fit_transform(X_kc_prices)

X_3_kc_prices.shape

reg_poly2_kc = LinearRegression().fit(X_3_kc_prices, y_kc_prices)
reg_poly2_kc.score(X_3_kc_prices, y_kc_prices)

y_pred_kc_prices = reg_poly2_kc.predict(X_3_kc_prices)
plt.scatter(y_pred_kc_prices, y_kc_prices)
plt.plot(y_pred_kc_prices, y_pred_kc_prices, c='r')

"""##Задания для самостоятельного выполнения

#### 1. В выполненной работе добавьте замер времени обучения каждой модели.
"""

import time

"""#### 2. На датасете "gen_regression" постройте модель пятого, десятого и сотого порядков. Сравните эффективность и время обучения каждой модели."""

data = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/gen_regression.csv")

X = pd.DataFrame(data.x)
y = data.y

# Построение моделей и измерение времени обучения
degrees = [5, 10, 100]
for degree in degrees:
    # Полиномиальное преобразование данных
    transformation = PolynomialFeatures(degree=degree)
    X_transformed = transformation.fit_transform(X)

    # Обучение модели
    start_time = time.time()
    poly_model = LinearRegression().fit(X_transformed, y)
    end_time = time.time()

    # Оценка эффективности
    score = poly_model.score(X_transformed, y)

    # Вывод графика
    xx_poly = np.arange(X.x.min(), X.x.max(), 0.01).reshape(-1, 1)
    xx_poly_transformed = transformation.transform(xx_poly)
    yy_poly = poly_model.predict(xx_poly_transformed)

    plt.scatter(X, y, label='Исходные данные')
    plt.plot(xx_poly, yy_poly, c='r', label=f'Полином {degree}-го порядка')
    plt.title(f'Полиномиальная регрессия {degree}-го порядка')
    plt.xlabel('X')
    plt.ylabel('y')
    plt.legend()
    plt.show()

    print(f"Модель {degree}-го порядка:")
    print(f"  Время обучения: {end_time - start_time:.4f} секунд")
    print(f"  Коэффициент детерминации: {score:.4f}\n")

"""####3. То же самое проделайте с датасетом для классификации и "King county"."""

from sklearn.metrics import accuracy_score

# Загрузка данных
data_classification = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/gen_classification.csv", index_col=0)

y_classification = data_classification.y
X_classification = data_classification.drop(["y"], axis=1)

# Построение моделей и измерение времени обучения
degrees_classification = [5, 10, 100]
for degree in degrees_classification:
    # Полиномиальное преобразование данных
    class_transform = PolynomialFeatures(degree=degree, include_bias=False)
    X_transformed_class = class_transform.fit_transform(X_classification)

    # Обучение модели
    start_time = time.time()
    class_model = LogisticRegression().fit(X_transformed_class, y_classification)
    end_time = time.time()

    # Оценка эффективности
    accuracy = accuracy_score(y_classification, class_model.predict(X_transformed_class))

    # Вывод графика
    xx_class = np.linspace(X_classification.min().min(), X_classification.max().max(), 300)
    yy_class = np.linspace(X_classification.min().min(), X_classification.max().max(), 300)
    xx_class, yy_class = np.meshgrid(xx_class, yy_class)
    XX_class = np.c_[xx_class.ravel(), yy_class.ravel()]
    Z_class = class_model.predict(class_transform.transform(XX_class)).reshape(xx_class.shape)

    plt.contourf(xx_class, yy_class, Z_class, alpha=0.4)
    plt.scatter(X_classification.iloc[:, 0][y_classification == 0], X_classification.iloc[:, 1][y_classification == 0], marker="o", c='r', s=100)
    plt.scatter(X_classification.iloc[:, 0][y_classification == 1], X_classification.iloc[:, 1][y_classification == 1], marker="x", c='b', s=100)
    plt.title(f'Полиномиальная классификация {degree}-го порядка')
    plt.xlabel('X1')
    plt.ylabel('X2')
    plt.show()

    print(f"Модель {degree}-го порядка:")
    print(f"  Время обучения: {end_time - start_time:.4f} секунд")
    print(f"  Точность: {accuracy:.4f}\n")

from sklearn.metrics import r2_score
from sklearn.utils import shuffle

# Загрузка данных
data_kc_prices = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/kc_house_data.csv")

# Выборка данных и уменьшение размера
sample_size = 1000
data_kc_prices_sampled = shuffle(data_kc_prices)[:sample_size]

y_kc_prices = data_kc_prices_sampled.price
X_kc_prices = data_kc_prices_sampled.drop(["id", "date", "price", "yr_renovated", "zipcode", "condition", "grade", "floors", "long", "view", "bedrooms", "bathrooms", "waterfront"], axis=1)

# Построение моделей и измерение времени обучения
degrees_kc_prices = [3, 5, 7]  # Уменьшим степени полинома
for degree in degrees_kc_prices:
    # Полиномиальное преобразование данных
    poly_features_kc_prices = PolynomialFeatures(degree=degree, include_bias=False)
    X_3_kc_prices = poly_features_kc_prices.fit_transform(X_kc_prices)

    # Обучение модели
    start_time = time.time()
    poly_model_kc_prices = LinearRegression().fit(X_3_kc_prices, y_kc_prices)
    end_time = time.time()

    # Оценка эффективности
    r2 = r2_score(y_kc_prices, poly_model_kc_prices.predict(X_3_kc_prices))

    print(f"Модель {degree}-го порядка:")
    print(f"  Время обучения: {end_time - start_time:.4f} секунд")
    print(f"  Коэффициент детерминации: {r2:.4f}\n")

    # График предсказаний
    y_pred_kc_prices = poly_model_kc_prices.predict(X_3_kc_prices)
    plt.scatter(y_pred_kc_prices, y_kc_prices)
    plt.plot(y_kc_prices, y_kc_prices, c='r')

    plt.title(f'Degree = {degree}; score = {poly_model_kc_prices.score(X_3_kc_prices, y_kc_prices)}; learning time = {end_time - start_time}')
    plt.xlabel('Предсказанные значения')
    plt.ylabel('Истинные значения')
    plt.show()

"""#### 4. Составьте таблицу эффективности разных моделей для каждой задачи. В таблице должна быть информация о времени обучения модели и получившейся точности. Сделайте вывод о целесообразности применения разных степеней полиномов."""

data_regression = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/gen_regression.csv")

# Выборка данных для регрессии и уменьшение размера
sample_size_regression = 100
data_regression_sampled = shuffle(data_regression)[:sample_size_regression]

X_regression = data_regression_sampled.x.values.reshape(-1, 1)
y_regression = data_regression_sampled.y.values

data_classification = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/gen_classification.csv")

# Выборка данных для классификации и уменьшение размера
sample_size_classification = 250
data_classification_sampled = shuffle(data_classification)[:sample_size_classification]

y_classification = data_classification_sampled.y.values
X_classification = data_classification_sampled.drop("y", axis=1).values

data_kc_prices = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/kc_house_data.csv")

# Выборка данных для регрессии на реальных данных и уменьшение размера
sample_size_kc_prices = 1000
data_kc_prices_sampled = shuffle(data_kc_prices)[:sample_size_kc_prices]

y_kc_prices = data_kc_prices_sampled.price
X_kc_prices = data_kc_prices_sampled.drop(["id", "date", "price", "yr_renovated", "zipcode", "condition", "grade", "floors", "long", "view", "bedrooms", "bathrooms", "waterfront"], axis=1)

results = []

# Регрессия
degrees_regression = [2, 5, 10]
for degree in degrees_regression:
    poly_features_regression = PolynomialFeatures(degree=degree, include_bias=False)
    X_3_regression = poly_features_regression.fit_transform(X_regression)

    start_time = time.time()
    poly_model_regression = LinearRegression().fit(X_3_regression, y_regression)
    end_time = time.time()

    r2_regression = r2_score(y_regression, poly_model_regression.predict(X_3_regression))

    results.append({
        'Task': 'Regression',
        'Degree': degree,
        'Time': end_time - start_time,
        'R2 Score': r2_regression
    })

# Классификация
degrees_classification = [2, 3, 5]
for degree in degrees_classification:
    poly_features_classification = PolynomialFeatures(degree=degree, include_bias=False)
    X_3_classification = poly_features_classification.fit_transform(X_classification)

    start_time = time.time()
    poly_model_classification = LogisticRegression().fit(X_3_classification, y_classification)
    end_time = time.time()

    accuracy_classification = accuracy_score(y_classification, poly_model_classification.predict(X_3_classification))

    results.append({
        'Task': 'Classification',
        'Degree': degree,
        'Time': end_time - start_time,
        'Accuracy': accuracy_classification
    })

# Регрессия на реальных данных
degrees_kc_prices = [3, 5, 7]
for degree in degrees_kc_prices:
    poly_features_kc_prices = PolynomialFeatures(degree=degree, include_bias=False)
    X_3_kc_prices = poly_features_kc_prices.fit_transform(X_kc_prices)

    start_time = time.time()
    poly_model_kc_prices = LinearRegression().fit(X_3_kc_prices, y_kc_prices)
    end_time = time.time()

    r2_kc_prices = r2_score(y_kc_prices, poly_model_kc_prices.predict(X_3_kc_prices))

    results.append({
        'Task': 'Regression on Real Data',
        'Degree': degree,
        'Time': end_time - start_time,
        'R2 Score': r2_kc_prices
    })

results_df = pd.DataFrame(results)
print(results_df)

"""#### 5. Для линейной модели в задаче о продаже домов выведите коэффициенты модели и названия соответствующих атрибутов. Сделайте вывод об относительной важности атрибутов."""

data_kc_prices = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/kc_house_data.csv")

# Выборка данных и уменьшение размера
sample_size = 1000
data_kc_prices_sampled = data_kc_prices.sample(sample_size, random_state=42)

y_kc_prices = data_kc_prices_sampled.price
X_kc_prices = data_kc_prices_sampled.drop(["id", "date", "price", "yr_renovated", "zipcode", "condition", "grade", "floors", "long", "view", "bedrooms", "bathrooms", "waterfront"], axis=1)

# Построение линейной модели
linear_model_kc_prices = LinearRegression().fit(X_kc_prices, y_kc_prices)

# Вывод коэффициентов и соответствующих атрибутов
coefficients = linear_model_kc_prices.coef_
attributes = X_kc_prices.columns

coefficients_df = pd.DataFrame({'Attribute': attributes, 'Coefficient': coefficients})
coefficients_df = coefficients_df.sort_values(by='Coefficient', ascending=False)

print("Коэффициенты модели:")
print(coefficients_df)

"""#### 6. Попробуйте также проинтерпретировать полиномиальную модель."""

data_kc_prices = pd.read_csv("https://raw.githubusercontent.com/koroteevmv/ML_course/2023/ML3.1%20polynomial%20features/kc_house_data.csv")

# Выборка данных и уменьшение размера
sample_size = 1000
data_kc_prices_sampled = shuffle(data_kc_prices)[:sample_size]

y_kc_prices = data_kc_prices_sampled.price
X_kc_prices = data_kc_prices_sampled.drop(["id", "date", "price", "yr_renovated", "zipcode", "condition", "grade", "floors", "long", "view", "bedrooms", "bathrooms", "waterfront"], axis=1)

# Построение полиномиальной модели второго порядка
degree = 2
poly_features_kc_prices = PolynomialFeatures(degree=degree, include_bias=False)
X_2_kc_prices = poly_features_kc_prices.fit_transform(X_kc_prices)

poly_model_kc_prices = LinearRegression().fit(X_2_kc_prices, y_kc_prices)

# Вывод коэффициентов и соответствующих атрибутов
coefficients = poly_model_kc_prices.coef_
feature_names = poly_features_kc_prices.get_feature_names_out(X_kc_prices.columns)

coefficients_df = pd.DataFrame({'Feature': feature_names, 'Coefficient': coefficients})
coefficients_df = coefficients_df.sort_values(by='Coefficient', ascending=False)

print("Коэффициенты полиномиальной модели второго порядка:")
print(coefficients_df)