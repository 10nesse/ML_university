# -*- coding: utf-8 -*-
"""ML3_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_bdeY04A6YPvEEE4aChQOMnDcy0MeXWA

##Методические указания
"""

from sklearn.datasets import make_blobs
import matplotlib.pyplot as plt

blob_centers = ([1, 1], [3, 4], [1, 3.3], [3.5, 1.8])
X, y = make_blobs(n_samples=200,
                          centers=blob_centers,
                          cluster_std=0.5,
                          random_state=0)

X[:, 0] *= 1000

plt.scatter(X[:, 0], X[:, 1], c=y,  edgecolors='black',linewidth=1)

from sklearn.neural_network import MLPClassifier

clf = MLPClassifier(hidden_layer_sizes=(6,),
                    random_state=1).fit(X, y)

print("Веса между входным и скрытым слоем:")
print(clf.coefs_[0])
print("\nВеса между скрытым и выходным слоем:")
print(clf.coefs_[1])

for i in range(len(clf.coefs_)):
    number_neurons_in_layer = clf.coefs_[i].shape[1]
    for j in range(number_neurons_in_layer):
        weights = clf.coefs_[i][:,j]
        print(i, j, weights, end=", ")
        print()
    print()

print("Веса смещения для скрытого слоя:")
print(clf.intercepts_[0])
print("\nВеса смещения для выходного слоя:")
print(clf.intercepts_[1])

from sklearn.metrics import confusion_matrix

confusion_matrix(y, clf.predict(X))

import numpy as np

X0 = np.linspace(X[:, 0].min()-1,X[:, 0].max()+1, X.shape[0])
X1 = np.linspace(X[:, 1].min()-1,X[:, 1].max()+1, X.shape[0])
X0_grid, X1_grid = np.meshgrid(X0, X1)

y_predict = clf.predict(np.c_[X0_grid.ravel(),X1_grid.ravel()]).reshape(X0_grid.shape)
plt.pcolormesh(X0_grid, X1_grid, y_predict)

plt.scatter(X[:, 0], X[:, 1], c=y,  edgecolors='black',linewidth=1)
plt.xlabel('X1')
plt.ylabel('X2')
plt.show()

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

scaler.fit(X)

X_scaled = scaler.transform(X)

clf = MLPClassifier(hidden_layer_sizes=(6,), max_iter=10_000, verbose=True).fit(X_scaled, y)

"""##Задания для самостоятельного выполнения

#### 1. Создайте однослойный перцептрон с 1, 2, 10 и 100 нейронами. Сравние их точность и сделайте вывод о достаточном количестве нейронов.
"""

from sklearn.model_selection import cross_val_score

accuracies = []

hidden_neurons = [1, 2, 10, 100]

for neurons in hidden_neurons:
    clf = MLPClassifier(hidden_layer_sizes=(neurons,), max_iter=1000, random_state=1)
    scores = cross_val_score(clf, X_scaled, y, cv=5)
    accuracies.append(scores.mean())

for neurons, accuracy in zip(hidden_neurons, accuracies):
    print(f"Количество нейронов: {neurons}, Точность: {accuracy}")

"""#### 2. Создайте и оцените модель с двумя, тремя и десятью скрытыми слоями с одинаковым количеством нейронов. Сравните их точность и сделайте вывод о достаточном количестве слоев."""

accuracies_layers = []

hidden_layers = [2, 3, 10]

hidden_neurons = (6,)

for layers in hidden_layers:
    clf = MLPClassifier(hidden_layer_sizes=(hidden_neurons * layers), max_iter=1000, random_state=1)
    scores = cross_val_score(clf, X_scaled, y, cv=5)
    accuracies_layers.append(scores.mean())

for layers, accuracy in zip(hidden_layers, accuracies_layers):
    print(f"Количество слоев: {layers}, Точность: {accuracy}")

"""####3. Для глубокой модели выведите веса всех нейронов на всех слоях. Выведите значения векторов весов смещения."""

clf_deep = MLPClassifier(hidden_layer_sizes=(6, 6, 6), max_iter=1000, random_state=1).fit(X_scaled, y)

for i, weights in enumerate(clf_deep.coefs_):
    print(f"Веса для слоя {i}:")
    print(weights)
    print()

for i, biases in enumerate(clf_deep.intercepts_):
    print(f"Веса смещения для слоя {i}:")
    print(biases)
    print()

"""#### 4. Постройте и оцените модель с большим количеством нейронов и слоев. Замерьте время выполнения обучения, сравните со временем обучения более простых моделей."""

import time

hidden_neurons = tuple(100 for _ in range(5))

start_time = time.time()
clf_large = MLPClassifier(hidden_layer_sizes=hidden_neurons, max_iter=1000, random_state=1).fit(X_scaled, y)
end_time = time.time()

training_time_large = end_time - start_time

accuracy_large = cross_val_score(clf_large, X_scaled, y, cv=5).mean()

print(f"Точность модели с большим количеством нейронов и слоев: {accuracy_large}")
print(f"Время обучения модели с большим количеством нейронов и слоев: {training_time_large} секунд")

"""#### 5. Постройте и оцените модель классификации с помощью перцептрона на датасете, который вы использовали на контрольной по классификиации (если вы ее не выполняли, возьмите любой датасет из раздела "real world datasets" в библиотеке sklearn).

"""

import pandas as pd

from sklearn.datasets import fetch_openml
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import Perceptron
from sklearn.metrics import accuracy_score

dataset_id = '40496'
dataset = fetch_openml(data_id=dataset_id, as_frame=True)

X = dataset.data
y = dataset.target

# Преобразование категориальных признаков в числовые (если есть)
if 'object' in str(X.dtypes):
    X = pd.get_dummies(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

clf = Perceptron()
clf.fit(X_train_scaled, y_train)

y_pred = clf.predict(X_test_scaled)

accuracy = accuracy_score(y_test, y_pred)
print("Точность модели перцептрона на тестовом наборе данных:", accuracy)

"""#### 6. Постройте и оцените модель регрессии с помощью перцептрона на датасете, который вы использовали на контрольной по регрессии."""

from sklearn.metrics import mean_squared_error

dataset = fetch_openml(data_id=198, as_frame=True)

X = dataset.data
y = dataset.target

threshold = y.mean()
y_binary = (y > threshold).astype(int)

X_train, X_test, y_train, y_test = train_test_split(X, y_binary, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

perceptron = Perceptron()
perceptron.fit(X_train_scaled, y_train)

y_pred = perceptron.predict(X_test_scaled)

mse = mean_squared_error(y_test, y_pred)
print("Среднеквадратичная ошибка модели перцептрона на тестовом наборе данных:", mse)

accuracy = accuracy_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)

print("Accuracy:", accuracy)
print("Recall:", recall)
print("Precision:", precision)