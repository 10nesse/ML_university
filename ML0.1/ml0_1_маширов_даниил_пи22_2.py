# -*- coding: utf-8 -*-
"""ML0.1_Маширов Даниил_ПИ22-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IcmVVx4qdcscIBFe4xNVROuf6lR2kztH

1) С помощью массивов numpy создайте таблицу умножения.
"""

import numpy as np

n = 10

multipliers = np.arange(1, n + 1)
result = np.outer(multipliers, multipliers)

print(result)

"""2) Создайте функцию, которая принимает как аргументы целое число N и первый элемент (вещественное число), и разность (вещественное число) и создает матрицу numpy по диагонали, которой располагаются первые N членов арифметической прогрессии."""

def create_arithmetic_progression_matrix(N, first_element, difference):
    progression = np.array([first_element + i * difference for i in range(N)])

    matrix = np.diag(progression)

    return matrix

N = 5
first_element = 2.0
difference = 3.0

result_matrix = create_arithmetic_progression_matrix(N, first_element, difference)
print(result_matrix)

"""3) Сгенерируйте средствами numpy матрицу А 5 на 5, содержащую последовательные числа от 1 до 25. Используя срезы извлеките в плоский массив все нечетные элементы этой матрицы."""

A = np.arange(1, 26).reshape(5, 5)

odd_elements = A[A % 2 != 0]

print(odd_elements)

"""4) Создайте двумерный массив, содержащий единицы на границе и нули внутри."""

rows, cols = 6, 8

array = np.zeros((rows, cols))

array[0, :] = 1  # Верхняя граница
array[-1, :] = 1  # Нижняя граница
array[:, 0] = 1  # Левая граница
array[:, -1] = 1  # Правая граница

print(array)

"""5) Создайте две матрицы размером (5,5). Одна матрица содержит 5 в шахматном порядке как в задаче домашнего задания, другая имеет треугольную форму содержащую 5 на основной диагонали и в позициях выше ее, а ниже все 0. Посчитайте их детерминант и найдите обратные матрицы."""

matrix1 = np.zeros((5, 5))
matrix1[1::2, ::2] = 5
matrix1[::2, 1::2] = 5

print("Первая матрица:")
print(matrix1)

matrix2 = np.tri(5, 5) * 5

print("\nВторая матрица:")
print(matrix2)

det_matrix1 = np.linalg.det(matrix1)
det_matrix2 = np.linalg.det(matrix2)

print(f"\nДетерминант первой матрицы: {det_matrix1}")
print(f"Детерминант второй матрицы: {det_matrix2}")

if det_matrix1 != 0:
    inv_matrix1 = np.linalg.inv(matrix1)
else:
    inv_matrix1 = "Обратной матрицы для первой матрицы не существует, так как ее детерминант равен 0."

if det_matrix2 != 0:
    inv_matrix2 = np.linalg.inv(matrix2)
else:
    inv_matrix2 = "Обратной матрицы для второй матрицы не существует, так как ее детерминант равен 0."

print("\nОбратная матрица для первой матрицы:")
print(inv_matrix1)

print("\nОбратная матрица для второй матрицы:")
print(inv_matrix2)

"""6) С помощью pandas загрузите датасет для предсказания цены квартиры, прилагающийся к этой работе."""

import pandas as pd

df = pd.read_csv('data.csv')

"""7) Выведите на экран несколько первых и несколько последний строк файла.

"""

print("Первые 5 строк:")
print(df.head())

print("\nПоследние 5 строк:")
print(df.tail())

"""8) Выведите с помощью методов pandas основные количественные параметры датасета: количество строк и столбцов, тип данных каждого поля, количество значений в каждом столбце, шкала измерения каждого численного поля."""

print("Общая информация о датасете:")
print(df.info())

"""9) Удалите из таблицы столбцы, содержащие идентификаторы, переименуйте все оставшиеся названия колонок на русском языке."""

df = pd.read_csv('data.csv')

df = df.drop(['Id'], axis=1)

df = df.rename(columns={
    'DistrictId': 'Район',
    'Rooms': 'Количество_комнат',
    'Square': 'Площадь',
    'LifeSquare': 'Жилая_площадь',
    'KitchenSquare': 'Площадь_кухни',
    'Floor': 'Этаж',
    'HouseFloor': 'Этаж_дома',
    'HouseYear': 'Год_постройки',
    'Ecology_1': 'Экология_1',
    'Ecology_2': 'Экология_2',
    'Ecology_3': 'Экология_3',
    'Social_1': 'Социальный_показатель_1',
    'Social_2': 'Социальный_показатель_2',
    'Social_3': 'Социальный_показатель_3',
    'Healthcare_1': 'Здравоохранение_1',
    'Helthcare_2': 'Здравоохранение_2',
    'Shops_1': 'Количество_магазинов_1',
    'Shops_2': 'Количество_магазинов_2',
    'Price': 'Цена'
})

print(df.head())

"""10) Выведите отдельно столбец, содержащий цену, по номеру и названию. Выведите первую, десятую и предпоследнюю строку таблицы по номеру и по индексу.

"""

# Вывод столбца с ценами по номеру (нумерация столбцов начинается с 0)
price_column_by_number = df.iloc[:, 18]  # 18 - номер столбца с ценами

price_column_by_name = df['Цена']

print("Столбец с ценами по номеру:")
print(price_column_by_number)

print("\nСтолбец с ценами по названию:")
print(price_column_by_name)

# Вывод первой, десятой и предпоследней строки по номеру
print("\nПервая строка по номеру:")
print(df.iloc[0, :])

print("\nДесятая строка по номеру:")
print(df.iloc[9, :])

print("\nПредпоследняя строка по номеру:")
print(df.iloc[-2, :])

# Вывод первой, десятой и предпоследней строки по индексу
print("\nПервая строка по индексу:")
print(df.loc[0, :])

print("\nДесятая строка по индексу:")
print(df.loc[9, :])

print("\nПредпоследняя строка по индексу:")
print(df.loc[df.index[-2], :])

"""11) Выделите в отдельную таблицу последние десять строк. Уберите в ней столбец с ценой. Склейте ее с первоначальной таблицей при помощи append. Заполните отсутствующие значения цены средним по таблице."""

last_10_rows = df.tail(10)

last_10_rows = last_10_rows.drop(columns=['Цена'])

mean_price = df['Цена'].mean()

last_10_rows['Цена'] = mean_price

merged_df = df.append(last_10_rows)

print(merged_df.head())
print(merged_df.tail())

"""12) Выделите пять последних колонок в отдельную таблицу. Удалите в ней строки, в которых цена ниже среднего. Присоедините эту таблицу к изначальной (выберите самый подходящий тип соединения)."""

last_5_columns = df.iloc[:, -5:]

mean_price = df['Цена'].mean()

filtered_last_5_columns = last_5_columns[df['Цена'] >= mean_price]

merged_df = pd.concat([df, filtered_last_5_columns], axis=1)

print(merged_df.head())
print(merged_df.tail())

"""13) Выведите таблицу, содержащую среднюю цену и количество квартир на каждом этаже из первоначального набора данных."""

result_df = df.groupby('Этаж').agg({'Цена': 'mean', 'Этаж': 'count'})

result_df = result_df.rename(columns={'Цена': 'Средняя_цена', 'Этаж': 'Количество_квартир'})

print(result_df)

"""14) Сохраните получившуюся таблицу в файлы формата csv и xlsx. Прочитайте их и убедитесь, что данные отображаются корректно."""

result_df.to_csv('result.csv', index=False)

with pd.ExcelWriter('result.xlsx') as writer:
    result_df.to_excel(writer, sheet_name='Sheet1', index=False)

"""15) Создайте в Excel или другом табличном редакторе таблицу, содержащую несколько численных и текстовых полей. Прочитайте ее в программу при помощи pandas."""

own_data_df = pd.read_excel('own_data.xlsx')

print(own_data_df.head())

"""17) Постройте круговую диаграмму для признака Rooms, иллюстрирующую количество квартир в процентах в зависимости от количества комнат."""

import matplotlib.pyplot as plt

df = pd.read_csv('data.csv')

room_counts = df['Rooms'].value_counts()

plt.figure(figsize=(8, 8))
plt.pie(room_counts, labels=room_counts.index, autopct='%1.1f%%', startangle=140, labeldistance=1.15)
plt.title('Количество квартир в зависимости от количества комнат')
plt.axis('equal')


plt.show()

"""18) Постройте гистограмму по целевой переменной Price. Оцените визуально, по какой цене продаётся наибольшее количество квартир."""

plt.figure(figsize=(10, 6))
plt.hist(df['Price'], bins=30, color='blue', edgecolor='black')
plt.title('Гистограмма цен на квартиры')
plt.xlabel('Цена')
plt.ylabel('Количество квартир')
plt.grid(True)

plt.show()

"""19) Постройте диаграммы рассеяния для признаков Rooms, Square, HouseFloor, HouseYear в зависимости от целевой переменной Price в одной области figure. Оцените визуально, есть ли среди них такие, на которых разброс точек близок к линейной функции."""

df = pd.read_csv('data.csv')

plt.figure(figsize=(18, 6))

# Rooms
plt.subplot(1, 4, 1)
plt.scatter(df['Rooms'], df['Price'], alpha=0.5)
plt.title('Зависимость Price от Rooms')
plt.xlabel('Rooms')
plt.ylabel('Price')

# Square
plt.subplot(1, 4, 2)
plt.scatter(df['Square'], df['Price'], alpha=0.5)
plt.title('Зависимость Price от Square')
plt.xlabel('Square')
plt.ylabel('Price')

# HouseFloor
plt.subplot(1, 4, 3)
plt.scatter(df['HouseFloor'], df['Price'], alpha=0.5)
plt.title('Зависимость Price от HouseFloor')
plt.xlabel('HouseFloor')
plt.ylabel('Price')

# HouseYear
plt.subplot(1, 4, 4)
plt.scatter(df['HouseYear'], df['Price'], alpha=0.5)
plt.title('Зависимость Price от HouseYear')
plt.xlabel('HouseYear')
plt.ylabel('Price')

plt.tight_layout()
plt.show()

"""20) Постройте ядерную оценку плотности целевой переменной Price. Оцените визуально, напоминает ли полученный график нормальное распределение. Постройте двумерную ядерную оценку плотности для целевой переменной Price и признака HouseFloor, затем оцените визуально на каких этажах и по какой цене продаётся основная масса квартир."""

import seaborn as sns

plt.figure(figsize=(12, 5))

# Ядерная оценка плотности для Price
plt.subplot(1, 2, 1)
sns.kdeplot(df['Price'], fill=True, color='blue')
plt.title('Ядерная оценка плотности для Price')
plt.xlabel('Price')
plt.ylabel('Плотность')

# Двумерная ядерная оценка плотности для Price и HouseFloor
plt.subplot(1, 2, 2)
sns.kdeplot(data=df, x='Price', y='HouseFloor', cmap='viridis', fill=True)
plt.title('Двумерная ядерная оценка плотности\nдля Price и HouseFloor')
plt.xlabel('Price')
plt.ylabel('HouseFloor')

plt.tight_layout()
plt.show()

"""21) Постройте ящиковую диаграмму признака Square. Оцените визуально имеются ли выбросы, и, если да, то начиная с какого размера площади значение признака можно считать выбросом."""

plt.figure(figsize=(8, 6))
sns.boxplot(x=df['Square'], color='green')
plt.title('Ящиковая диаграмма для признака Square')
plt.xlabel('Square')

plt.show()

"""22) При помощи сетки графиков PairGrid визуализируйте попарные отношения признаков Rooms, Square, HouseFloor, HouseYear, Price следующим образом: на диагонали - гистограммы, под диагональю - ядерные"""

features = ['Rooms', 'Square', 'HouseFloor', 'HouseYear', 'Price']

# Создание сетки графиков PairGrid
g = sns.PairGrid(df[features])

# Верхний треугольник: ядерные оценки плотности
g.map_lower(sns.kdeplot, cmap='Blues_d')

# Диагональ: гистограммы
g.map_diag(plt.hist, color='blue', alpha=0.7)

g.fig.suptitle('Попарные отношения признаков', y=1.02)

plt.show()

"""23) Постройте тепловую карту матрицы корреляции (df.corr()) признаков Rooms, Square, HouseFloor, HouseYear, Price. По ней определите, какие признаки являются зависимыми (у таких признаков коэффициент корреляции близок к единице)."""

df = pd.read_csv('data.csv')

features = ['Rooms', 'Square', 'HouseFloor', 'HouseYear', 'Price']

correlation_matrix = df[features].corr()

plt.figure(figsize=(10, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, fmt=".2f")
plt.title('Тепловая карта матрицы корреляции')
plt.show()